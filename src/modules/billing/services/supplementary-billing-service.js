'use strict';

const { groupBy, pick, omit, last, negate, flatMap, mapValues, sortBy } = require('lodash');
const moment = require('moment');
const newRepos = require('../../../lib/connectors/repos');

const billingTransactionsRepo = require('../../../lib/connectors/repos/billing-transactions');
const Transaction = require('../../../lib/models/transaction');

const Decimal = require('decimal.js-light');

/**
 * These are the keys in the abstractionPeriod field
 * By specifying the keys we guarantee their ordering
 */
const abstractionPeriodKeys = [
  'startDay',
  'startMonth',
  'endDay',
  'endMonth'
];

/**
 * These are the common keys for all transactions when
 * generating a grouping key.
 * TPT and annual transactions have a slightly different
 * grouping key - this list of keys is therefore
 * augmented in the function below
 */
const commonTransactionKeys = [
  'authorisedDays',
  'source',
  'season',
  'loss',
  'chargeType',
  'volume',
  'section126Factor',
  'section127Agreement',
  'section130Agreement',
  'isTwoPartTariffSupplementary',
  'isNewLicence',
  'invoiceAccountNumber',
  'financialYearEnding'
];

const omitKeys = [
  'licenceId',
  'financialYearEnding',
  'invoiceAccountNumber',
  'billingTransactionId',
  'isCurrentBatch',
  'billingBatchId',
  'isSummer'
];

/**
 * Gets a grouping key for the given transaction - this is to allow
 * similar transactions to be grouped together
 *
 * Similar transactions may have been generated by different charge elements,
 * but they share all the parameters that affect the billed amount
 *
 * @param {Object} transaction
 * @return {String} grouping key
 */
const getGroupingKey = transaction => {
  // Create a list of keys which will form the grouping key
  const keys = [...commonTransactionKeys];
  transaction.isTwoPartTariffSupplementary
    ? keys.push('isSummer')
    : keys.push('authorisedDays', 'volume');

  // Get the data and serialize to a JSON string
  const data = {
    ...pick(transaction, keys),
    description: transaction.description.trim().toLowerCase(),
    abstractionPeriod: pick(transaction.abstractionPeriod, abstractionPeriodKeys)
  };
  return JSON.stringify(data);
};

const xor = (a, b) => a ? !b : b;

/**
 * Maps an array of transactions to a data structure which includes a summed total
 *
 * The summed total sums:
 * - billable days in the group (for annual)
 * - volumes in the group (for TPT)
 *
 * Depending on whether the transaction is a credit, and whether it is in the current
 * batch, it is negated.  This means where a transaction in a sent batch has the
 * same billable days/volume as one in the current batch, they will sum to zero
 * and the transaction in the current batch will then be deleted.
 *
 * If the sum is non-zero, then transactions will remain in the current batch.
 *
 * @param {String} batchId
 * @param {Array<Object>} transactions
 * @return {Object} data structure containing { transactions: [], sum }
 */
const mapTransactionGroup = (batchId, transactions) => transactions.reduce((acc, transaction) => {
  const isCurrentBatch = transaction.billingBatchId === batchId;
  const propertyKey = transaction.isTwoPartTariffSupplementary ? 'volume' : 'billableDays';
  let value = new Decimal(transaction[propertyKey]);
  if (xor(transaction.isCredit, !isCurrentBatch)) {
    value = value.negated();
  }

  return {
    transactions: [...acc.transactions, {
      ...transaction,
      isCurrentBatch
    }],
    sum: acc.sum.plus(value)
  };
}, {
  transactions: [],
  sum: new Decimal(0)
});

/**
 * Predicate to check if this transaction should be considered.
 *
 * We only wish to consider standard and compensation charges.
 * Minumum charge correction transactions are omitted.
 *
 * @param {Object} transaction
 * @return {Boolean}
 */
const isValidTransaction = transaction =>
  ['standard', 'compensation'].includes(transaction.chargeType);

/**
 * Predicate to check if transaction is part of the current batch
 *
 * @param {Object} transaction
 * @return {Boolean}
 */
const isCurrentBatchTransaction = transaction => transaction.isCurrentBatch;

/**
 * Predicate to check if transaction is part of an existing batch
 *
 * @param {Object} transaction
 * @return {Boolean}
 */
const isExistingBatchTransaction = negate(isCurrentBatchTransaction);

/**
 * Gets transaction ID from transaction
 *
 * @param {Object} transaction
 * @return {String}
 */
const getTransactionId = transaction => transaction.billingTransactionId;

/**
 * Deletes all transactions in the given group that are
 * in the current batch
 *
 * @param {Object} group
 * @param {Array<Object>} group.transactions
 * @return {Promise}
 */
const deleteGroupTransactions = group => {
  const ids = group.transactions
    .filter(isCurrentBatchTransaction)
    .map(getTransactionId);
  return billingTransactionsRepo.delete(ids);
};

/**
 * Gets the changes to apply to a transaction in the current batch
 *
 * @param {Object} transaction
 * @param {Decimal} sum
 * @return {Object}
 */
const getChanges = (transaction, sum) => {
  const absoluteValue = sum.absoluteValue();
  const isCredit = sum.isNegative();
  return transaction.isTwoPartTariffSupplementary
    ? { isCredit, volume: absoluteValue.toFixed(6) }
    : { isCredit, billableDays: absoluteValue.toNumber() };
};

/**
 * Gets a key for pairing transactions within a group which have the same:
 * - Charge period
 * - Billable days (for annual transactions)
 * - Volume (for TPT transactions)
 *
 * @param {Object} transaction
 * @return {String}
 */
const getPairGroupingKey = transaction => {
  const keys = ['startDate', 'endDate'];
  keys.push(
    transaction.isTwoPartTariffSupplementary ? 'volume' : 'billableDays'
  );
  return JSON.stringify(pick(transaction, keys));
};

/**
 * Filters cancelling transactions in the supplied list
 *
 * The transactions are sorted by date created, and then reduced to the minumum amount
 * of credits/charges to have the same financial effect
 *
 * The transactions supplied should already be sorted into a similar group
 *
 * E.g.
 *
 * Charge transaction - remove
 * Credit transaction - remove
 * Charge transaction - keep
 *
 * @param {Array<Object>} transactions
 * @return {Array<Object>}
 */
const filterCancellingTransactions = transactions => {
  return sortBy(transactions, transaction => moment(transaction.dateCreated).unix())
    .reduce((acc, transaction) => {
      const index = acc.findIndex(row => row.isCredit === !transaction.isCredit);
      index === -1 ? acc.push(transaction) : acc.splice(index, 1);
      return acc;
    }, []);
};

/**
 * Looks at all the transactions in a group, and returns a new array of
 * transasctions with "pairs" (e.g. credits and charges that cancel each other)
 * removed
 *
 * @param {Array<Object>} transactions
 * @return {Array<Object>} transactions with cancelling pairs removed
 */
const getNonCancellingTransactions = transactions => {
  const pairGroups = groupBy(transactions, getPairGroupingKey);
  const filteredGroups = mapValues(pairGroups, filterCancellingTransactions);
  return flatMap(Object.values(filteredGroups));
};

const getReversedTransaction = sourceTransaction => ({
  ...getNewTransaction(sourceTransaction),
  isCredit: !sourceTransaction.isCredit
});

/**
 * Updates a transaction in the current batch
 *
 * @param {Object} transaction
 * @param {Decimal} sum
 * @return {Promise}
 */
const reverseExistingTransactions = async group => {
  const existingBatchTransactions = group.transactions.filter(isExistingBatchTransaction);

  // Get a list of transactions to reverse
  const effectiveTransactions = getNonCancellingTransactions(existingBatchTransactions);

  const reversedTransactions = effectiveTransactions.map(getReversedTransaction);

  for (const reversedTransaction of reversedTransactions) {
    await billingTransactionsRepo.create(reversedTransaction);
  }
};

const getNewTransaction = sourceTransaction => ({
  ...omit(sourceTransaction, omitKeys),
  sourceTransactionId: sourceTransaction.billingTransactionId,
  status: Transaction.statuses.candidate,
  legacyId: null,
  externalId: null
});

/**
 * Creates a new transaction in the current batch using a
 * transaction from a previous batch as the template
 *
 * The most recent transaction is used in cases where
 * there are >1
 *
 * @param {Object} transactionGroup
 * @param {Decimal} sum
 * @return {Promise}
 */
const createTransaction = transactionGroup => {
  const sourceTransaction = last(transactionGroup.transactions);

  const transaction = {
    ...getNewTransaction(sourceTransaction),
    ...getChanges(sourceTransaction, transactionGroup.sum)
  };
  return billingTransactionsRepo.create(transaction);
};

/**
 * Processes a transaction group and takes one of 3 actions:
 *
 * - Removes all transactions in the current batch if the sum is zero
 * - Updates the transaction in the current batch if found to create a zero sum
 * - Creates a new transaction by copying one from a previous batch to create a zero sum
 *
 * @param {Object} group
 * @param {Array} group.transactions
 * @param {Decimal} group.sum
 * @return {Promise}
 */
const processTransactionGroup = async group => {
  // If group sums to zero, we don't need any adjustments in this group.
  // Delete all batch transactions
  if (group.sum.equals(0)) {
    await deleteGroupTransactions(group);
  } else {
    // If there is already a transaction in the current batch for this group, it is
    // updated
    const currentBatchTransaction = group.transactions.find(isCurrentBatchTransaction);
    if (currentBatchTransaction) {
      return reverseExistingTransactions(group);
    } else {
      // If there are no transaction in current batch, we create a new one using a transaction from a
      // past batch as a template
      return createTransaction(group);
    }
  }
};

/**
 * Processes the supplementary billing batch specified by
 * deleting some transactions in the batch and crediting others
 * previously billed
 * @param {String} batchId
 * @reutrn {Promise}
 */
const processBatch = async batchId => {
  // Loads:
  // - transactions in current batch
  // - historical transactions relating to licences in current batch
  const [batchTransactions, historicalTransactions] = await Promise.all([
    newRepos.billingTransactions.findByBatchId(batchId),
    newRepos.billingTransactions.findHistoryByBatchId(batchId)
  ]);

  // Valid transactions excludes min charge transactions
  const validTransactions = [...batchTransactions, ...historicalTransactions].filter(isValidTransaction);

  // Group transactions with similar properties
  const transactionGroups = groupBy(validTransactions, getGroupingKey);

  // Sum totals in each group
  const groupsWithTotals = Object.values(transactionGroups).map(transactions => mapTransactionGroup(batchId, transactions));

  for (const group of groupsWithTotals) {
    await processTransactionGroup(group);
  }
};

exports.processBatch = processBatch;
