'use strict';

const { groupBy, pick, omit, last } = require('lodash');
const newRepos = require('../../../lib/connectors/repos');

const billingTransactionsRepo = require('../../../lib/connectors/repos/billing-transactions');
const Transaction = require('../../../lib/models/transaction');

const Decimal = require('decimal.js-light');

/**
 * These are the keys in the abstractionPeriod field
 * By specifying the keys we guarantee their ordering
 */
const abstractionPeriodKeys = [
  'startDay',
  'startMonth',
  'endDay',
  'endMonth'
];

/**
 * These are the common keys for all transactions when
 * generating a grouping key.
 * TPT and annual transactions have a slightly different
 * grouping key - this list of keys is therefore
 * augmented in the function below
 */
const commonTransactionKeys = [
  'authorisedDays',
  'source',
  'season',
  'loss',
  'chargeType',
  'volume',
  'section126Factor',
  'section127Agreement',
  'section130Agreement',
  'isTwoPartTariffSupplementary',
  'isNewLicence',
  'invoiceAccountNumber',
  'financialYearEnding'
];

/**
 * Gets a grouping key for the given transaction - this is to allow
 * similar transactions to be grouped together
 *
 * Similar transactions may have been generated by different charge elements,
 * but they share all the parameters that affect the billed amount
 *
 * @param {Object} transaction
 * @return {String} grouping key
 */
const getGroupingKey = transaction => {
  // Create a list of keys which will form the grouping key
  const keys = [...commonTransactionKeys];
  transaction.isTwoPartTariffSupplementary
    ? keys.push('isSummer')
    : keys.push('authorisedDays', 'volume');

  // Get the data and serialize to a JSON string
  const data = {
    ...pick(transaction, keys),
    description: transaction.description.trim().toLowerCase(),
    abstractionPeriod: pick(transaction.abstractionPeriod, abstractionPeriodKeys)
  };
  return JSON.stringify(data);
};

const xor = (a, b) => a ? !b : b;

/**
 * Maps an array of transactions to a data structure which includes a summed total
 *
 * The summed total sums:
 * - billable days in the group (for annual)
 * - volumes in the group (for TPT)
 *
 * Depending on whether the transaction is a credit, and whether it is in the current
 * batch, it is negated.  This means where a transaction in a sent batch has the
 * same billable days/volume as one in the current batch, they will sum to zero
 * and the transaction in the current batch will then be deleted.
 *
 * If the sum is non-zero, then transactions will remain in the current batch.
 *
 * @param {String} batchId
 * @param {Array<Object>} transactions
 * @return {Object} data structure containing { transactions: [], sum }
 */
const mapTransactionGroup = (batchId, transactions) => transactions.reduce((acc, transaction) => {
  const isCurrentBatch = transaction.billingBatchId === batchId;
  const propertyKey = transaction.isTwoPartTariffSupplementary ? 'volume' : 'billableDays';
  let value = new Decimal(transaction[propertyKey]);
  if (xor(transaction.isCredit, !isCurrentBatch)) {
    value = value.negated();
  }

  return {
    transactions: [...acc.transactions, {
      ...transaction,
      isCurrentBatch
    }],
    sum: acc.sum.plus(value)
  };
}, {
  transactions: [],
  sum: new Decimal(0)
});

/**
 * Predicate to check if this transaction should be considered.
 *
 * We only wish to consider standard and compensation charges.
 * Minumum charge correction transactions are omitted.
 *
 * @param {Object} transaction
 * @return {Boolean}
 */
const isValidTransaction = transaction =>
  ['standard', 'compensation'].includes(transaction.chargeType);

/**
 * Predicate to check if transaction is part of the current batch
 *
 * @param {Object} transaction
 * @return {Boolean}
 */
const isCurrentBatchTransaction = transaction => transaction.isCurrentBatch;

/**
 * Gets transaction ID from transaction
 *
 * @param {Object} transaction
 * @return {String}
 */
const getTransactionId = transaction => transaction.billingTransactionId;

/**
 * Deletes all transactions in the given group that are
 * in the current batch
 *
 * @param {Object} group
 * @param {Array<Object>} group.transactions
 * @return {Promise}
 */
const deleteGroupTransactions = group => {
  const ids = group.transactions
    .filter(isCurrentBatchTransaction)
    .map(getTransactionId);
  return billingTransactionsRepo.delete(ids);
};

/**
 * Gets the changes to apply to a transaction in the current batch
 *
 * @param {Object} transaction
 * @param {Decimal} sum
 * @return {Object}
 */
const getChanges = (transaction, sum) => {
  const absoluteValue = sum.absoluteValue();
  const isCredit = sum.isNegative();
  return transaction.isTwoPartTariffSupplementary
    ? { isCredit, volume: absoluteValue.toFixed(6) }
    : { isCredit, billableDays: absoluteValue.toNumber() };
};

/**
 * Updates a transaction in the current batch
 *
 * @param {Object} transaction
 * @param {Decimal} sum
 * @return {Promise}
 */
const updateCurrentBatchTransaction = (transaction, sum) => {
  const changes = getChanges(transaction, sum);
  return billingTransactionsRepo.update(transaction.billingTransactionId, changes);
};

/**
 * Creates a new transaction in the current batch using a
 * transaction from a previous batch as the template
 *
 * The most recent transaction is used in cases where
 * there are >1
 *
 * @param {Object} transactionGroup
 * @param {Decimal} sum
 * @return {Promise}
 */
const createTransaction = transactionGroup => {
  const sourceTransaction = last(transactionGroup.transactions);

  const transaction = {
    ...omit(sourceTransaction, [
      'licenceId',
      'financialYearEnding',
      'invoiceAccountNumber',
      'billingTransactionId',
      'isCurrentBatch',
      'billingBatchId',
      'isSummer'
    ]),
    ...getChanges(sourceTransaction, transactionGroup.sum),
    sourceTransactionId: sourceTransaction.billingTransactionId,
    status: Transaction.statuses.candidate,
    legacyId: null,
    externalId: null
  };
  return billingTransactionsRepo.create(transaction);
};

/**
 * Processes a transaction group and takes one of 3 actions:
 *
 * - Removes all transactions in the current batch if the sum is zero
 * - Updates the transaction in the current batch if found to create a zero sum
 * - Creates a new transaction by copying one from a previous batch to create a zero sum
 *
 * @param {*} group
 */
const processTransactionGroup = async group => {
  // If group sums to zero, we don't need any adjustments in this group.
  // Delete all batch transactions
  if (group.sum.equals(0)) {
    await deleteGroupTransactions(group);
  } else {
    // If there is already a transaction in the current batch for this group, it is
    // updated
    const currentBatchTransaction = group.transactions.find(isCurrentBatchTransaction);
    if (currentBatchTransaction) {
      return updateCurrentBatchTransaction(currentBatchTransaction, group.sum);
    } else {
      // If there is no transaction, we create a new one using a transaction from a
      // past batch as a template
      return createTransaction(group);
    }
  }
};

/**
 * Processes the supplementary billing batch specified by
 * deleting some transactions in the batch and crediting others
 * previously billed
 * @param {String} batchId
 * @reutrn {Promise}
 */
const processBatch = async batchId => {
  // Loads:
  // - transactions in current batch
  // - historical transactions relating to licences in current batch
  const [batchTransactions, historicalTransactions] = await Promise.all([
    newRepos.billingTransactions.findByBatchId(batchId),
    newRepos.billingTransactions.findHistoryByBatchId(batchId)
  ]);

  // Valid transactions excludes min charge transactions
  const validTransactions = [...batchTransactions, ...historicalTransactions].filter(isValidTransaction);

  // Group transactions with similar properties
  const transactionGroups = groupBy(validTransactions, getGroupingKey);

  // Sum totals in each group
  const groupsWithTotals = Object.values(transactionGroups).map(transactions => mapTransactionGroup(batchId, transactions));

  for (const group of groupsWithTotals) {
    await processTransactionGroup(group);
  }
};

exports.processBatch = processBatch;
